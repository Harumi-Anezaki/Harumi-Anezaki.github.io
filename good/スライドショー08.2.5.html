<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スライドショー</title>
    <style>
        /* --- ページのスタイル (CSS) --- */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f4f7f9;
            color: #333;
            overflow: hidden; /* アプリ全体のスクロールを禁止 */
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 250px;
            background-color: #ffffff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
            flex-shrink: 0; /* サイドバーが縮まないようにする */
            transition: width 0.3s ease-in-out, padding 0.3s ease-in-out, border 0.3s ease-in-out;
            position: relative;
        }
        /* サイドバーが閉じた状態のスタイル */
        #sidebar.closed {
            width: 0;
            padding-left: 0;
            padding-right: 0;
            border-right-width: 0;
            overflow: hidden;
        }

        #sidebar h2 {
            margin: 0 0 15px 0;
            font-size: 1.2em;
            color: #1a253c;
            white-space: nowrap; /* 閉じるアニメーション中に改行させない */
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px; /* スライドショーコントロールとの間隔 */
            white-space: nowrap;
        }

        .button-group .btn, .slideshow-controls .btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
        }

        #file-input-label { background-color: #007bff; color: white; }
        #file-input-label:hover { background-color: #0056b3; }
        #delete-all-btn { background-color: #6c757d; color: white; }
        #delete-all-btn:hover { background-color: #5a6268; }
        #file-input { display: none; }

        /* --- スライドショーコントロールのスタイル --- */
        .slideshow-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
            white-space: nowrap;
        }
        #slideshow-interval {
            width: 60px;
            padding: 9px;
            border: 1px solid #ccc;
            border-radius: 5px;
            text-align: center;
            font-size: 1em;
        }
        #slideshow-interval:disabled {
            background-color: #e9ecef;
            cursor: not-allowed;
        }
        .slideshow-controls label {
            font-size: 0.9em;
            color: #555;
        }
        #slideshow-toggle-btn {
            background-color: #28a745;
            color: white;
        }
        #slideshow-toggle-btn:hover { background-color: #218838; }
        #slideshow-toggle-btn.running {
            background-color: #dc3545; /* 実行中は赤色に */
        }
        #slideshow-toggle-btn.running:hover { background-color: #c82333; }


        #file-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }

        #file-list li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        #file-list li:hover { background-color: #e9ecef; }

        #file-list li a {
            flex-grow: 1;
            padding: 10px 15px;
            text-decoration: none;
            color: #007bff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #file-list li a.active {
            background-color: #007bff;
            color: white;
            font-weight: bold;
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        #file-list li:has(a.active) { background-color: transparent; }

        .delete-btn {
            background: none; border: none; cursor: pointer; color: #dc3545;
            padding: 10px; font-size: 1.1em; opacity: 0.6; transition: opacity 0.2s;
        }
        .delete-btn:hover { opacity: 1; }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative; /* トグルボタンとナビゲーションボタンの位置基準 */
        }

        /* サイドバートグルボタン */
        #sidebar-toggle-btn {
            position: absolute;
            top: 20px;
            left: -15px; /* ボタンの半分だけメインコンテンツ側にはみ出す */
            z-index: 1000;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid #d0d0d0;
            background-color: white;
            color: #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            line-height: 1;
            padding: 0;
            box-shadow: 0 1px 4px rgba(0,0,0,0.15);
            transition: transform 0.2s ease, background-color 0.2s ease;
        }
        #sidebar-toggle-btn:hover {
            background-color: #f0f0f0;
            transform: scale(1.1);
        }

        /* --- ナビゲーションボタンのスタイル --- */
        .nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 900;
            width: 40px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s, background-color 0.2s;
            display: none; /* 初期状態は非表示 */
            pointer-events: none; /* Opacity 0 の時にクリックできないように */
        }
        #main-content:hover .nav-btn {
            opacity: 1;
            pointer-events: auto;
        }
        .nav-btn:hover {
            background-color: rgba(0, 0, 0, 0.6);
        }
        #prev-btn { left: 15px; }
        #next-btn { right: 15px; }


        #content-frame { width: 100%; height: 100%; border: none; }
        #placeholder {
            display: flex; align-items: center; justify-content: center;
            height: 100%; text-align: center; color: #888; font-size: 1.5em;
        }

        /* --- 再読み込みボタンのスタイル --- */
        #reload-permission-btn {
            display: block;
            width: calc(100% - 20px);
            margin: 10px;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-size: 0.9em;
        }
        #reload-permission-btn:hover {
            background-color: #0056b3;
        }
        #reload-permission-btn small {
            display: block;
            font-weight: normal;
            opacity: 0.8;
            margin-top: 4px;
        }
    </style>
</head>
<body>

    <div class="app-container">
        <!-- 左側のサイドバー -->
        <nav id="sidebar">
            <h2>ファイル一覧</h2>
		<div class="button-group">
                <button id="select-folder-btn" class="btn">フォルダ選択</button>
                <button id="delete-all-btn" class="btn">フォルダ解除</button>
            </div>
            <!-- スライドショーコントロール -->
            <div class="slideshow-controls">
                <input type="number" id="slideshow-interval" value="1" min="0.1" step="0.1" title="読み込み完了後の待ち時間">
                <label for="slideshow-interval">秒</label>
                <button id="slideshow-toggle-btn" class="btn">開始</button>
            </div>

            <ul id="file-list"></ul>
        </nav>

        <!-- 右側のコンテンツ表示エリア -->
        <main id="main-content">
            <!-- サイドバートグルボタン -->
            <button id="sidebar-toggle-btn" title="サイドバーを閉じる (Ctrl + \)"></button>

            <div id="placeholder">
                <p>←でHTMLファイルを追加し、<br>ファイル名をクリックするとここに表示されます。</p>
            </div>

            <!-- ナビゲーションボタン -->
            <button id="prev-btn" class="nav-btn" title="前のファイル">‹</button>
            <button id="next-btn" class="nav-btn" title="次のファイル">›</button>

            <iframe id="content-frame" name="contentFrame" title="アップロードされたHTMLコンテンツ"></iframe>
        </main>
    </div>

    <script>
    // --- DOM要素の取得 ---
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.getElementById('sidebar-toggle-btn');
    const selectFolderBtn = document.getElementById('select-folder-btn'); 
    const fileList = document.getElementById('file-list');
    const contentFrame = document.getElementById('content-frame');
    const placeholder = document.getElementById('placeholder');
    const deleteAllBtn = document.getElementById('delete-all-btn');
    // 新しく追加した要素
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const slideshowIntervalInput = document.getElementById('slideshow-interval');
    const slideshowToggleBtn = document.getElementById('slideshow-toggle-btn');


    // --- IndexedDBの設定 ---
    const DB_NAME = 'htmlViewerDB_FolderAccess';
    const DB_VERSION = 1;
    const STORE_NAME = 'directoryHandles';
    let db;
    const fileUrlMap = new Map();
    const fileHandleMap = new Map(); 
    let directoryHandle = null; 

    // --- スライドショーの状態管理 ---
    let slideshowTimer = null;
    let isSlideshowRunning = false;
    let isSlideshowPaused = false;
    let slideshowStartTime;
    let slideshowRemainingTime;

    // --- サイドバー開閉機能 ---
    function toggleSidebar(force) {
        const isClosed = sidebar.classList.toggle('closed', force);
        localStorage.setItem('sidebarClosed', isClosed);
        if (isClosed) {
            toggleBtn.innerHTML = '»';
            toggleBtn.title = 'サイドバーを開く (Ctrl + \\)';
        } else {
            toggleBtn.innerHTML = '«';
            toggleBtn.title = 'サイドバーを閉じる (Ctrl + \\)';
        }
    }

     // --- IndexedDB関連の関数群 ---
    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    // キーパスは不要
                    db.createObjectStore(STORE_NAME);
                }
            };
            request.onsuccess = (event) => { db = event.target.result; resolve(db); };
            request.onerror = (event) => { reject(event.target.error); };
        });
    }
    function saveHandleToDB(handle) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            // 'currentHandle' という固定キーでハンドルを保存
            const request = store.put(handle, 'currentHandle');
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }
    function getHandleFromDB() {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get('currentHandle');
            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }
    function deleteHandleFromDB() {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.delete('currentHandle');
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    // --- UI更新関連の関数群 ---
    function updateFileListUI(fileHandles) {
        fileList.innerHTML = '';
        revokeAllObjectURLs();
        fileHandleMap.clear(); // ハンドルマップもクリア

        if (fileHandles.length === 0) {
            showPlaceholder();
            return;
        }
        // ファイル名でソート
        fileHandles.sort((a, b) => a.name.localeCompare(b.name));

        fileHandles.forEach(handle => {
            fileHandleMap.set(handle.name, handle); // マップに登録
            const listItem = createFileListItem(handle);
            fileList.appendChild(listItem);
        });
    }
    function createFileListItem(fileHandle) {
        // この時点ではBlob URLを生成しない
        const listItem = document.createElement('li');
        const link = document.createElement('a');
        link.href = '#';
        link.textContent = fileHandle.name;
        link.dataset.fileName = fileHandle.name;
        link.addEventListener('click', (e) => {
            e.preventDefault();
            if (isSlideshowRunning) {
                clearTimeout(slideshowTimer);
            }
            showContent(fileHandle.name);
        });
        // 個別削除ボタンはフォルダ単位の管理では不要なため削除
        listItem.appendChild(link);
        return listItem;
    }
    async function showContent(fileName) {
        const handle = fileHandleMap.get(fileName);
        if (!handle) return;

        try {
            const file = await handle.getFile();
            // 表示直前にBlob URLを生成
            const fileURL = URL.createObjectURL(file);
            // 古いURLがあれば解放
            if (fileUrlMap.has(fileName)) {
                URL.revokeObjectURL(fileUrlMap.get(fileName));
            }
            fileUrlMap.set(fileName, fileURL);

            placeholder.style.display = 'none';
            contentFrame.style.display = 'block';
            prevBtn.style.display = 'block';
            nextBtn.style.display = 'block';
            contentFrame.src = fileURL;
            contentFrame.dataset.currentFile = fileName;
            updateActiveLink(fileName);
        } catch (error) {
            console.error(`'${fileName}'の読み込みに失敗しました:`, error);
            alert(`'${fileName}'へのアクセスが拒否されたか、ファイルが存在しません。`);
        }
    }
    function showPlaceholder() {
        contentFrame.style.display = 'none';
        contentFrame.src = 'about:blank';
        contentFrame.dataset.currentFile = '';
        placeholder.style.display = 'flex';
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
        updateActiveLink(null);
        stopSlideshow(); // ファイルがなくなったらスライドショーも停止
    }
    function updateActiveLink(activeFileName) {
        document.querySelectorAll('#file-list a').forEach(a => {
            if (a.dataset.fileName === activeFileName) {
                a.classList.add('active');
            } else {
                a.classList.remove('active');
            }
        });
    }
    function revokeAllObjectURLs() {
        for (const url of fileUrlMap.values()) {
            URL.revokeObjectURL(url);
        }
        fileUrlMap.clear();
    }
    function revokeObjectURL(fileName) {
        if (fileUrlMap.has(fileName)) {
            URL.revokeObjectURL(fileUrlMap.get(fileName));
            fileUrlMap.delete(fileName);
        }
    }

    // --- 再読み込みUI制御関数 ---
    function showReloadPermissionUI(handle, onReload) {
        fileList.innerHTML = ''; // リストをクリア
        const listItem = document.createElement('li');
        const reloadBtn = document.createElement('button');
        reloadBtn.id = 'reload-permission-btn';
        reloadBtn.innerHTML = `フォルダ「<b>${handle.name}</b>」を再読み込み<small>クリックしてアクセスを許可</small>`;
        
        reloadBtn.addEventListener('click', async () => {
            // ボタンを無効化して多重クリックを防ぐ
            reloadBtn.disabled = true;
            reloadBtn.textContent = '許可を確認中...';
            await onReload();
        }, { once: true }); // イベントは一度だけ実行

        listItem.appendChild(reloadBtn);
        fileList.appendChild(listItem);
    }


    // --- ナビゲーション & スライドショー関連関数 ---
    function getCurrentFileIndex() {
        const currentFileName = contentFrame.dataset.currentFile;
        if (!currentFileName) return -1;
        const links = Array.from(fileList.querySelectorAll('a'));
        return links.findIndex(a => a.dataset.fileName === currentFileName);
    }

    function showFileByIndex(index) {
        const links = fileList.querySelectorAll('a');
        if (index >= 0 && index < links.length) {
            links[index].click();
        }
    }

    function showNextFile() {
        if (fileList.children.length === 0) return;
        let currentIndex = getCurrentFileIndex();
        const nextIndex = (currentIndex + 1) % fileList.children.length;
        showFileByIndex(nextIndex);
    }

    function showPrevFile() {
        if (fileList.children.length === 0) return;
        let currentIndex = getCurrentFileIndex();
        const prevIndex = (currentIndex - 1 + fileList.children.length) % fileList.children.length;
        showFileByIndex(prevIndex);
    }

    function startSlideshow() {
        if (fileList.children.length === 0) {
            alert('スライドショーを開始するファイルがありません。');
            return;
        }
        isSlideshowRunning = true;
        isSlideshowPaused = false;
        slideshowToggleBtn.textContent = '停止';
        slideshowToggleBtn.classList.add('running');
        slideshowIntervalInput.disabled = true;

        if (getCurrentFileIndex() === -1) {
            showFileByIndex(0); // 最初のファイルから開始
        } else {
            // 現在のファイルからタイマーを開始
            startSlideshowTimer(parseFloat(slideshowIntervalInput.value) * 1000);
        }
    }

    function stopSlideshow() {
        clearTimeout(slideshowTimer);
        slideshowTimer = null;
        isSlideshowRunning = false;
        isSlideshowPaused = false;
        slideshowToggleBtn.textContent = '開始';
        slideshowToggleBtn.classList.remove('running');
        slideshowIntervalInput.disabled = false;
    }

    function toggleSlideshow() {
        if (isSlideshowRunning) {
            stopSlideshow();
        } else {
            startSlideshow();
        }
    }

    function startSlideshowTimer(duration) {
        clearTimeout(slideshowTimer);
        slideshowStartTime = Date.now();
        slideshowRemainingTime = duration;
        slideshowTimer = setTimeout(showNextFile, duration);
    }

    function togglePauseSlideshow() {
        if (!isSlideshowRunning) return;

        isSlideshowPaused = !isSlideshowPaused;
        if (isSlideshowPaused) {
            clearTimeout(slideshowTimer);
            const elapsedTime = Date.now() - slideshowStartTime;
            slideshowRemainingTime -= elapsedTime;
            slideshowToggleBtn.textContent = '再開';
        } else {
            slideshowToggleBtn.textContent = '停止';
            if (slideshowRemainingTime > 0) {
                startSlideshowTimer(slideshowRemainingTime);
            } else {
                showNextFile(); // ポーズ中に時間が過ぎていたら即座に次へ
            }
        }
    }

// --- File System Access API 関連関数 ---

    async function verifyPermission(handle) {
        const options = { mode: 'read' };
        if (await handle.queryPermission(options) === 'granted') {
            return true;
        }
        if (await handle.requestPermission(options) === 'granted') {
            return true;
        }
        return false;
    }

    async function loadFilesFromHandle(handle) {
        const fileHandles = [];
        for await (const entry of handle.values()) {
            if (entry.kind === 'file' && (entry.name.endsWith('.html') || entry.name.endsWith('.htm'))) {
                fileHandles.push(entry);
            }
        }
        updateFileListUI(fileHandles);
        if (fileHandles.length > 0) {
            showContent(fileHandles[0].name); // 最初のファイルを表示
        }
    }

    async function selectFolder() {
        try {
            const handle = await window.showDirectoryPicker();
            directoryHandle = handle;
            await saveHandleToDB(handle);
            await loadFilesFromHandle(handle);
        } catch (error) {
            // ユーザーがダイアログをキャンセルした場合など
            console.log('フォルダ選択がキャンセルされました:', error);
        }
    }


    // --- File System Access API 関連関数 ---

    async function verifyPermission(handle) {
        const options = { mode: 'read' };
        // 既に許可されているか確認
        if (await handle.queryPermission(options) === 'granted') {
            return true;
        }
        // 許可をリクエスト
        if (await handle.requestPermission(options) === 'granted') {
            return true;
        }
        // 許可されなかった場合
        return false;
    }

    async function loadFilesFromHandle(handle) {
        const fileHandles = [];
        // フォルダ内のエントリを非同期でループ処理
        for await (const entry of handle.values()) {
            // ファイルであり、拡張子が .html または .htm の場合のみ追加
            if (entry.kind === 'file' && (entry.name.endsWith('.html') || entry.name.endsWith('.htm'))) {
                fileHandles.push(entry);
            }
        }
        updateFileListUI(fileHandles); // UIを更新
        if (fileHandles.length > 0) {
            // 最初のファイルが選択された状態で表示
            showContent(fileHandles[0].name);
        }
    }

    async function selectFolder() {
        try {
            // フォルダ選択ダイアログを表示
            const handle = await window.showDirectoryPicker();
            directoryHandle = handle; // グローバル変数にハンドルを保持
            await saveHandleToDB(handle); // IndexedDBにハンドルを保存
            await loadFilesFromHandle(handle); // フォルダ内のファイルを読み込んで表示
        } catch (error) {
            // ユーザーがダイアログをキャンセルした場合のエラーは無視
            console.log('フォルダ選択がキャンセルされました:', error);
        }
    }

    // --- メイン処理とイベントリスナー ---

    document.addEventListener('DOMContentLoaded', async () => {
        const isSidebarClosed = localStorage.getItem('sidebarClosed') === 'true';
        toggleSidebar(isSidebarClosed);
        showPlaceholder();
        try {
            await initDB();
            const handle = await getHandleFromDB();

            if (handle) {
                // まず権限があるか静かに確認
                if (await handle.queryPermission({ mode: 'read' }) === 'granted') {
                    // 権限が既にある場合はそのまま読み込む
                    directoryHandle = handle;
                    await loadFilesFromHandle(handle);
                } else {
                    // 権限がない場合は、クリックで再許可を求めるUIを表示
                    showReloadPermissionUI(handle, async () => {
                        if (await verifyPermission(handle)) {
                            directoryHandle = handle;
                            await loadFilesFromHandle(handle);
                        } else {
                            // 許可されなかった場合は、ボタンを再度有効にしてメッセージを戻す
                            alert('フォルダへのアクセスが許可されませんでした。');
                            showReloadPermissionUI(handle, arguments.callee); // 同じコールバックで再試行可能にする
                        }
                    });
                }
            }
        } catch (error) {
            console.error('アプリケーションの初期化に失敗しました:', error);
            alert('データベースの読み込みに失敗しました。');
        }
    });

    toggleBtn.addEventListener('click', () => toggleSidebar());

    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === '\\') {
            e.preventDefault();
            toggleSidebar();
        }
        if (e.code === 'Space' && !e.target.matches('input, button')) {
            if (isSlideshowRunning) {
                e.preventDefault();
                togglePauseSlideshow();
            }
        }
    });

    selectFolderBtn.addEventListener('click', selectFolder);

     deleteAllBtn.addEventListener('click', async () => {
        if (!directoryHandle) {
            alert('解除するフォルダが選択されていません。');
            return;
        }
        if (confirm('選択されているフォルダの関連付けを解除しますか？')) {
            try {
                await deleteHandleFromDB(); // DBからハンドルを削除
                directoryHandle = null; // グローバル変数をリセット
                fileList.innerHTML = ''; // UIリストをクリア
                revokeAllObjectURLs(); // メモリ解放
                fileHandleMap.clear(); // ハンドルマップをクリア
                showPlaceholder(); // 初期画面に戻す
                alert('フォルダの関連付けが解除されました。');
            } catch (error) {
                console.error('フォルダ解除に失敗しました:', error);
                alert('フォルダの解除中にエラーが発生しました。');
            }
        }
    });

    // ナビゲーションとスライドショーのイベントリスナー
    prevBtn.addEventListener('click', showPrevFile);
    nextBtn.addEventListener('click', showNextFile);
    slideshowToggleBtn.addEventListener('click', toggleSlideshow);

    // iframeの読み込みが完了したらスライドショーのタイマーを開始する
    contentFrame.addEventListener('load', () => {
        if (isSlideshowRunning && !isSlideshowPaused) {
            const interval = parseFloat(slideshowIntervalInput.value) * 1000;
            if (!isNaN(interval) && interval > 0) {
                startSlideshowTimer(interval);
            }
        }
    });

    window.addEventListener('beforeunload', revokeAllObjectURLs);

    </script>

</body>
</html>
