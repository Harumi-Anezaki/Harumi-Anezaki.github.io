<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube風コメント欄</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesomeのリンクは不要なため削除しました -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9f9f9;
        }
        .comment-avatar, .reply-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }
        .reply-avatar { /* 返信コメント用のアバターは少し小さくする例 */
            width: 28px;
            height: 28px;
        }
        .comment-input-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
        }
        .comment-textarea, .reply-textarea {
            border: none;
            border-bottom: 1px solid #ccc;
            resize: none;
            outline: none;
            transition: border-bottom-color 0.3s;
        }
        .comment-textarea:focus, .reply-textarea:focus {
            border-bottom: 2px solid #065fd4;
        }
        .action-button { /* 返信ボタンなどの汎用ボタンスタイル */
            background-color: transparent;
            border: none;
            color: #606060;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px; 
            transition: background-color 0.2s;
            font-size: 0.875rem; 
            font-weight: 500;
        }
        .action-button:hover {
            background-color: #e0e0e0;
        }
        .submit-button {
            background-color: #065fd4;
            color: white;
            padding: 8px 16px;
            border-radius: 18px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .submit-button:hover {
            background-color: #054bb8;
        }
        .submit-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .cancel-button {
            background-color: transparent;
            color: #606060;
            padding: 8px 16px;
            border-radius: 18px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .cancel-button:hover {
            background-color: #e9e9e9;
        }
        .comment-input-buttons, .reply-input-buttons {
            display: none; 
            justify-content: flex-end;
            gap: 8px;
            margin-top: 8px;
        }
        .comment-item, .reply-item { 
            position: relative; 
        }
        .replies-container { 
            margin-left: 0; 
            padding-left: 0;
            border-left: none;
            margin-top: 0.75rem; 
        }
        .replies-list { 
            margin-left: 48px; 
            padding-left: 16px;
            border-left: 2px solid #e0e0e0;
            space-y: 0.75rem; 
        }
        .reply-input-area {
            margin-top: 8px;
            margin-left: 48px; 
        }

    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-3xl mx-auto bg-white p-4 md:p-6 rounded-lg shadow">
        <h2 class="text-xl font-semibold mb-4">コメント <span id="comment-count">3</span>件</h2>

        <!-- AI 設定セクション -->
        <div class="mb-6 p-4 border border-gray-300 rounded-md">
            <h3 class="text-lg font-semibold mb-2">設定</h3>
            <div class="mb-2">
                <label for="api-key-input" class="block text-sm font-medium text-gray-700">Gemini APIキー:</label>
                <input type="password" id="api-key-input" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="APIキーを入力">
            </div>
            <div class="mb-2">
                <label for="model-name-input" class="block text-sm font-medium text-gray-700">モデル名:</label>
                <input type="text" id="model-name-input" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" value="gemini-2.0-flash">
            </div>
            <div class="flex space-x-2 mt-3">
                <button id="start-ai-button" class="submit-button text-sm px-3 py-1">開始</button>
                <button id="stop-ai-button" class="cancel-button text-sm px-3 py-1" disabled>停止</button>
            </div>
            <p id="ai-status" class="text-xs text-gray-500 mt-1">停止中...</p>
        </div>

        <!-- メインコメント入力欄 -->
        <div class="flex items-start space-x-3 mb-6">
            <img src="https://placehold.co/32x32/7B68EE/FFFFFF?text=U" alt="あなたのプロフィール画像" class="comment-input-avatar">
            <div class="flex-1">
                <textarea id="new-comment-text" class="w-full p-2 comment-textarea" placeholder="コメントを追加..." rows="1"></textarea>
                <div id="comment-input-buttons-container" class="comment-input-buttons">
                    <button id="cancel-comment-button" class="cancel-button">キャンセル</button>
                    <button id="submit-comment-button" class="submit-button" disabled>コメント</button>
                </div>
            </div>
        </div>

        <!-- コメントリスト -->
        <div id="comments-list" class="space-y-6">
            <!-- コメント1 (例) -->
            <div class="flex items-start space-x-3 comment-item" data-comment-id="comment-0">
                <img src="https://placehold.co/40x40/2196F3/FFFFFF?text=D" alt="ユーザーDのプロフィール画像" class="comment-avatar">
                <div class="flex-1">
                    <div class="flex items-center space-x-1">
                        <p class="font-semibold text-sm">ユーザーD</p>
                        <p class="text-xs text-gray-500" data-timestamp="${new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()}">3 日前</p>
                    </div>
                    <p class="text-sm mt-1 comment-text">シンプルで分かりやすい！</p>
                    <div class="flex items-center space-x-2 mt-2 text-xs">
                        <button class="action-button reply-button">返信</button>
                    </div>
                    <div class="reply-input-container mt-2"></div>
                    <div class="replies-container">
                        <div class="replies-list space-y-3"></div>
                    </div>
                </div>
            </div>
            
            <!-- コメント2 (例) -->
            <div class="flex items-start space-x-3 comment-item" data-comment-id="comment-1">
                <img src="https://placehold.co/40x40/4CAF50/FFFFFF?text=B" alt="ユーザーBのプロフィール画像" class="comment-avatar">
                <div class="flex-1">
                    <div class="flex items-center space-x-1">
                        <p class="font-semibold text-sm">ユーザーB</p>
                        <p class="text-xs text-gray-500" data-timestamp="${new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString()}">5 時間前</p>
                    </div>
                    <p class="text-sm mt-1 comment-text">うーん、私はあまり同意できません。別の視点もあると思います。</p>
                    <div class="flex items-center space-x-2 mt-2 text-xs">
                        <button class="action-button reply-button">返信</button>
                    </div>
                    <div class="reply-input-container mt-2"></div>
                    <div class="replies-container">
                        <div class="replies-list space-y-3">
                        <!-- 返信コメントの例 -->
                        <div class="flex items-start space-x-3 reply-item" data-comment-id="comment-1-reply-0">
                             <img src="https://placehold.co/28x28/E91E63/FFFFFF?text=C" alt="ユーザーCのプロフィール画像" class="reply-avatar">
                             <div class="flex-1">
                                 <div class="flex items-center space-x-1">
                                     <p class="font-semibold text-xs">ユーザーC</p>
                                     <p class="text-xs text-gray-500" data-timestamp="${new Date(Date.now() - 1 * 60 * 60 * 1000).toISOString()}">1 時間前</p>
                                 </div>
                                 <p class="text-xs mt-1 comment-text">@ユーザーB なるほど、そういう考え方もありますね。</p>
                                 <div class="flex items-center space-x-2 mt-1 text-xs">
                                      <button class="action-button reply-button">返信</button>
                                 </div>
                                 <div class="reply-input-container mt-2"></div>
                                 <div class="replies-container">
                                     <div class="replies-list space-y-3"></div>
                                 </div>
                             </div>
                         </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- コメント3 (例) -->
            <div class="flex items-start space-x-3 comment-item" data-comment-id="comment-2">
                <img src="https://placehold.co/40x40/FFC107/000000?text=A" alt="ユーザーAのプロフィール画像" class="comment-avatar">
                <div class="flex-1">
                    <div class="flex items-center space-x-1">
                        <p class="font-semibold text-sm">ユーザーA</p>
                        <p class="text-xs text-gray-500" data-timestamp="${new Date().toISOString()}">ついさっき</p>
                    </div>
                    <p class="text-sm mt-1 comment-text">これは素晴らしい動画ですね！とても参考になりました。特に最後の部分が良かったです。</p>
                    <div class="flex items-center space-x-2 mt-2 text-xs">
                        <button class="action-button reply-button">返信</button>
                    </div>
                    <div class="reply-input-container mt-2"></div>
                    <div class="replies-container">
                        <div class="replies-list space-y-3"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDKのインポート
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, addDoc, getDoc, getDocs, collection, query, where, onSnapshot, serverTimestamp, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const newCommentText = document.getElementById('new-comment-text');
        const submitCommentButton = document.getElementById('submit-comment-button');
        const cancelCommentButton = document.getElementById('cancel-comment-button');
        const commentInputButtonsContainer = document.getElementById('comment-input-buttons-container');
        const commentsList = document.getElementById('comments-list');
        const commentCountSpan = document.getElementById('comment-count');

        const apiKeyInput = document.getElementById('api-key-input');
        const modelNameInput = document.getElementById('model-name-input');
        const startAiButton = document.getElementById('start-ai-button');
        const stopAiButton = document.getElementById('stop-ai-button');
        const aiStatus = document.getElementById('ai-status');

        let nextCommentIdCounter = 3; 
        let aiIntervalId = null;
        let aiPersonalities = []; 

        // --- Firebase関連 ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'youtube-comments-ai-dev';
        const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
        let db, auth, userId;
        let firebaseInitialized = false;

        if (firebaseConfigStr) {
            try {
                const firebaseConfig = JSON.parse(firebaseConfigStr);
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); 
                firebaseInitialized = true;
                console.log("Firebase initialized successfully.");

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User is signed in with UID:", userId);
                        await loadPersonalities(); 
                    } else {
                        console.log("User is signed out. Attempting sign-in...");
                        try {
                            const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                            if (token) {
                                await signInWithCustomToken(auth, token);
                                console.log("Signed in with custom token.");
                            } else {
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously.");
                            }
                        } catch (error) {
                            console.error("Error during sign-in:", error);
                            aiStatus.textContent = "認証エラーが発生しました。";
                        }
                    }
                });
            } catch (e) {
                console.error("Firebase initialization failed:", e);
                aiStatus.textContent = "Firebaseの初期化に失敗しました。AI人格はローカルに保存されます。";
                firebaseInitialized = false;
            }
        } else {
            console.warn("Firebase config not found. AI personalities will be in-memory only.");
            aiStatus.textContent = "Firebase設定が見つかりません。AI人格はローカルに保存されます。";
            firebaseInitialized = false;
        }
        // --- ここまでFirebase関連 ---

        // メインコメント入力欄の制御
        newCommentText.addEventListener('focus', () => {
            newCommentText.rows = 3;
            commentInputButtonsContainer.style.display = 'flex';
        });
        newCommentText.addEventListener('input', () => {
            submitCommentButton.disabled = newCommentText.value.trim() === '';
        });
        cancelCommentButton.addEventListener('click', () => {
            newCommentText.value = '';
            newCommentText.rows = 1;
            submitCommentButton.disabled = true;
            commentInputButtonsContainer.style.display = 'none';
            newCommentText.blur();
        });

        // メインコメント投稿処理
        submitCommentButton.addEventListener('click', () => {
            const commentText = newCommentText.value.trim();
            if (commentText === '') return;
            addCommentToDOM(commentText, "あなた", `https://placehold.co/40x40/7B68EE/FFFFFF?text=U`, null);
            
            newCommentText.value = '';
            newCommentText.rows = 1;
            submitCommentButton.disabled = true;
            commentInputButtonsContainer.style.display = 'none';
            newCommentText.blur();
            updateTopLevelCommentCount();
        });

        // コメントや返信をDOMに追加する汎用関数
        function addCommentToDOM(text, author, avatarSrc, parentCommentId = null, personalityInfo = null, commentId = null) {
            const newCommentId = commentId || `comment-${nextCommentIdCounter++}-${Date.now()}`;
            const isReply = parentCommentId !== null;
            const timestamp = new Date().toISOString();

            const commentElement = document.createElement('div');
            commentElement.classList.add(isReply ? 'reply-item' : 'comment-item', 'flex', 'items-start', 'space-x-3');
            commentElement.dataset.commentId = newCommentId;
            if (personalityInfo) { 
                commentElement.dataset.aiPersonality = personalityInfo.username;
            }

            commentElement.innerHTML = `
                <img src="${avatarSrc}" alt="${author}のプロフィール画像" class="${isReply ? 'reply-avatar' : 'comment-avatar'}">
                <div class="flex-1">
                    <div class="flex items-center space-x-1">
                        <p class="font-semibold ${isReply ? 'text-xs' : 'text-sm'}">${escapeHTML(author)}</p>
                        <p class="text-xs text-gray-500" data-timestamp="${timestamp}">${formatTimeAgo(timestamp)}</p>
                    </div>
                    <p class="${isReply ? 'text-xs' : 'text-sm'} mt-1 comment-text">${escapeHTML(text)}</p>
                    <div class="flex items-center space-x-2 mt-${isReply ? '1' : '2'} text-xs">
                        <button class="action-button reply-button">返信</button>
                    </div>
                    <div class="reply-input-container mt-2"></div>
                    <div class="replies-container"> <div class="replies-list ${isReply ? 'space-y-2' : 'space-y-3'}"></div> </div>
                </div>
            `;

            const targetList = isReply 
                ? document.querySelector(`[data-comment-id="${parentCommentId}"] .replies-list`)
                : commentsList;

            if (targetList) {
                targetList.insertBefore(commentElement, targetList.firstChild);
            } else {
                if (isReply) console.error("Parent comment's replies list not found for ID:", parentCommentId);
                else console.error("Main comments list not found.");
                return; 
            }
            return newCommentId;
        }
        
        // 「返信」ボタンのイベント委任
        commentsList.addEventListener('click', function(event) {
            if (event.target.classList.contains('reply-button')) {
                handleReplyButtonClick(event);
            }
        });
        
        function handleReplyButtonClick(event) {
            const button = event.target;
            const parentCommentItem = button.closest('.comment-item, .reply-item');
            const parentCommentId = parentCommentItem.dataset.commentId;
            const replyInputContainer = parentCommentItem.querySelector('.reply-input-container');

            const existingReplyForm = document.getElementById('dynamic-reply-form');
            if (existingReplyForm) existingReplyForm.remove();

            const replyForm = document.createElement('div');
            replyForm.id = 'dynamic-reply-form';
            replyForm.classList.add('flex', 'items-start', 'space-x-2', 'mt-2', 'p-2', 'bg-gray-50', 'rounded-md');
            replyForm.innerHTML = `
                <img src="https://placehold.co/28x28/7B68EE/FFFFFF?text=U" alt="あなたのプロフィール画像" class="reply-avatar">
                <div class="flex-1">
                    <textarea class="w-full p-1 reply-textarea text-xs" placeholder="返信を追加..." rows="2"></textarea>
                    <div class="reply-input-buttons flex justify-end gap-2 mt-1" style="display: flex;">
                        <button class="cancel-reply-button cancel-button text-xs px-2 py-1">キャンセル</button>
                        <button class="submit-reply-button submit-button text-xs px-2 py-1" disabled>返信</button>
                    </div>
                </div>
            `;
            replyInputContainer.appendChild(replyForm);
            const replyTextarea = replyForm.querySelector('.reply-textarea');
            const submitReplyBtn = replyForm.querySelector('.submit-reply-button');
            const cancelReplyBtn = replyForm.querySelector('.cancel-reply-button');

            replyTextarea.focus();
            replyTextarea.addEventListener('input', () => {
                submitReplyBtn.disabled = replyTextarea.value.trim() === '';
            });
            cancelReplyBtn.addEventListener('click', () => replyForm.remove());
            submitReplyBtn.addEventListener('click', () => {
                const replyText = replyTextarea.value.trim();
                if (replyText === '') return;
                const replyingToUsername = parentCommentItem.querySelector('.font-semibold').textContent;
                const fullReplyText = `@${replyingToUsername} ${replyText}`;
                addCommentToDOM(fullReplyText, "あなた", `https://placehold.co/28x28/7B68EE/FFFFFF?text=U`, parentCommentId);
                replyForm.remove();
            });
        }

        function escapeHTML(str) {
            const p = document.createElement('p');
            p.textContent = str;
            return p.innerHTML;
        }
        
        function updateTopLevelCommentCount() {
            const topLevelCommentItems = commentsList.querySelectorAll(':scope > .comment-item');
            commentCountSpan.textContent = topLevelCommentItems.length;
        }

        function formatTimeAgo(isoTimestamp) {
            const date = new Date(isoTimestamp);
            const now = new Date();
            const seconds = Math.round((now - date) / 1000);
            if (seconds < 5) return "たった今";
            if (seconds < 60) return `${seconds}秒前`;
            const minutes = Math.round(seconds / 60);
            if (minutes < 60) return `${minutes}分前`;
            const hours = Math.round(minutes / 60);
            if (hours < 24) return `${hours}時間前`;
            const days = Math.round(hours / 24);
            return `${days}日前`;
        }
        
        // DOMContentLoadedで初期処理
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.comment-item, .reply-item').forEach(item => {
                const timeElement = item.querySelector('.text-xs.text-gray-500');
                if (timeElement && timeElement.dataset.timestamp) {
                    timeElement.textContent = formatTimeAgo(timeElement.dataset.timestamp);
                }
            });
            updateTopLevelCommentCount();
            // イベント委任に切り替えたため、個別の返信ボタンへのリスナーアタッチは不要
        });

        // --- AI関連のロジック ---
        async function loadPersonalities() {
            if (!firebaseInitialized || !db) {
                console.log("Firebase not ready, skipping personality load from DB.");
                return;
            }
            const personalitiesColPath = `artifacts/${appId}/public/data/ai-personalities`;
            const personalitiesCol = collection(db, personalitiesColPath);
            try {
                const snapshot = await getDocs(query(personalitiesCol, orderBy("createdAt", "desc"), limit(50))); 
                aiPersonalities = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                console.log("Loaded personalities from Firestore:", aiPersonalities.length, "found.");
            } catch (error) {
                console.error("Error loading personalities from Firestore:", error);
                aiStatus.textContent = "人格の読み込みに失敗しました。";
            }
        }

        async function savePersonality(username, personalityTrait, personalityPrompt, avatarSeed) {
            const newPersonality = { username, personalityTrait, personalityPrompt, avatarSeed, createdAt: new Date().toISOString() };
            if (!firebaseInitialized || !db) {
                newPersonality.id = `local-${Date.now()}`;
                aiPersonalities.push(newPersonality);
                console.log("Saved personality locally:", newPersonality);
                return newPersonality;
            }
            try {
                const personalitiesColPath = `artifacts/${appId}/public/data/ai-personalities`;
                const newDocRef = await addDoc(collection(db, personalitiesColPath), {
                    username,
                    personalityTrait, 
                    personalityPrompt, 
                    avatarSeed,
                    createdAt: serverTimestamp() 
                });
                newPersonality.id = newDocRef.id;
                aiPersonalities.push(newPersonality); 
                console.log("Personality saved to Firestore with ID:", newDocRef.id);
                return newPersonality;
            } catch (error) {
                console.error("Error saving personality to Firestore:", error);
                aiStatus.textContent = "人格の保存に失敗しました。";
                newPersonality.id = `local-fallback-${Date.now()}`;
                aiPersonalities.push(newPersonality);
                console.log("Saved personality locally as fallback:", newPersonality);
                return newPersonality;
            }
        }
        
        async function callGeminiAPI(prompt, currentApiKey, currentModelName) {
            const modelToUse = currentModelName || 'gemini-2.0-flash';
            if (!currentApiKey) {
                aiStatus.textContent = "APIキーが設定されていません。";
                console.error("API Key is missing.");
                return null;
            }
            
            aiStatus.textContent = ` 生成処理中...`; // より具体的に
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelToUse}:generateContent?key=${currentApiKey}`;
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { temperature: 0.8, maxOutputTokens: 200 } 
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                    return result.candidates[0].content.parts[0].text.trim();
                } else {
                    console.error("Gemini API response error or no content:", result);
                    const errorMessage = result.error?.message || JSON.stringify(result.error) || '不明なAPIエラー';
                    aiStatus.textContent = `AI: APIエラー (${errorMessage.substring(0, 50)}...)`;
                    return null;
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                aiStatus.textContent = `AI: API呼び出し失敗 (${error.message.substring(0,50)}...)`;
                return null;
            }
        }

        async function aiActionLoop() {
            const apiKey = apiKeyInput.value;
            const modelName = modelNameInput.value;

            if (!apiKey) {
                aiStatus.textContent = "AI処理停止: APIキーを入力してください。";
                stopAiCommenting();
                return;
            }

            let selectedPersonality;
            aiStatus.textContent = "AI: 人格を決定中...";
            if (Math.random() < 0.5 || aiPersonalities.length === 0) {
                const personaGenerationPrompt = `あなたは、日本のオンライン掲示板投稿者のペルソナを作成するAIアシスタントです。
ユーザー名(ネットスラング、奇抜な単語の組み合わせ、自虐ネタ、中二病的な響き、意味不明な記号列、アニメやゲームのキャラもじり、煽り文句など、一度見たら忘れられないような、強烈なインパクトを持つ名前。例： \`煽り神\`, \`†終末の使徒†\`, \`全レス乞食\`, \`壁のシミ\`, \`ゲスの極み乙\`)と、性格(煽り、自虐、電波系、ネタ発言、強いこだわり、斜に構えた態度、極端な思想、レスバトラー気質、謎の上から目線、過度な専門用語の乱用、意味不明なポエム、特定ジャンルへの異常な愛憎など、そのキャラクターの「ヤバさ」や「面白さ」が一言で伝わるようなもの。例： \`異論は認めん。ソースは俺。\`, \`今日も一日がんばるぞい！（白目）\`, \`宇宙の真理に気づいてしまった…\`, \`レスバトなら任せろ。かかってこい。\`, \`また髪の話してる…\`, \`すべては運命石の扉の選択だ。\`)を生成してください。
応答は、'userName'（文字列）と 'personalityDescription'（文字列）の2つのキーを持つJSONオブジェクト「のみ」で返してください。
例：
{
  "userName": "社畜ちゃん(Lv.5)",
  "personalityDescription": "推しが尊すぎて今日も墓建設中。"
}`;
                aiStatus.textContent = `AI: 新しい掲示板ペルソナを生成中...`;
                const personaJsonString = await callGeminiAPI(personaGenerationPrompt, apiKey, modelName);

                let successfullyCreatedPersona = false;
                if (personaJsonString) {
                    try {
                        // APIからの応答がマークダウンのコードブロック形式で返ってくる場合を考慮
                        const cleanedJsonString = personaJsonString.replace(/^```json\s*|```\s*$/g, '');
                        const parsedPersona = JSON.parse(cleanedJsonString);

                        if (parsedPersona.userName && parsedPersona.personalityDescription) {
                            const newUsername = parsedPersona.userName;
                            const personalityDescription = parsedPersona.personalityDescription;
                            const commentingSystemPrompt = `あなたは「${newUsername}」という名前の日本のオンライン掲示板の投稿者です。あなたの特徴的な性格・口調は「${personalityDescription}」です。この設定になりきってください。他のコメントや動画内容に対して、その性格でコメントや返信をしてください。コメントは常に短く、1～3文程度で、非常に個性的かつ掲示板らしいスタイルでお願いします。`;
                            const firstChar = newUsername.trim().charAt(0);
                            const avatarSeed = firstChar.match(/[a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/) ? firstChar.toUpperCase() : 'P';

                            selectedPersonality = await savePersonality(newUsername, personalityDescription, commentingSystemPrompt, avatarSeed);
                            aiStatus.textContent = `AI: 新人格「${selectedPersonality.username}」（性格: ${selectedPersonality.personalityTrait.substring(0,20)}...）を作成。`;
                            successfullyCreatedPersona = true;
                        } else {
                            throw new Error("生成されたJSONに必要なキー（userNameまたはpersonalityDescription）が含まれていません。");
                        }
                    } catch (e) {
                        console.error("ペルソナJSONの解析に失敗、または構造が無効です:", e, personaJsonString);
                        aiStatus.textContent = `AI: ペルソナJSON解析失敗。フォールバック人格を使用。`;
                    }
                } else {
                    aiStatus.textContent = `AI: ペルソナ生成API呼び出し失敗。フォールバック人格を使用。`;
                }

                if (!successfullyCreatedPersona) { 
                    const adj = ["ありふれた", "普通の", "平凡な", "どこにでもいる"];
                    const noun = ["一般人", "名無しさん", "通行人X", "その他大勢の一人"];
                    const personalityTrait = `${adj[Math.floor(Math.random() * adj.length)]} ${noun[Math.floor(Math.random() * noun.length)]}`;
                    const newUsername = `AI_${personalityTrait.replace(/\s/g,'')}${Math.floor(Math.random() * 100)}`;
                    const commentingSystemPrompt = `あなたは「${newUsername}」です。あなたの性格は「${personalityTrait}」です。コメントは常に短く、1～3文程度にしてください。`;
                    const avatarSeed = newUsername.replace(/AI/g,'').charAt(0).toUpperCase() || 'F';
                    selectedPersonality = await savePersonality(newUsername, personalityTrait, commentingSystemPrompt, avatarSeed);
                    aiStatus.textContent = `AI: フォールバック人格「${selectedPersonality.username}」を使用。`;
                }

            } else { 
                selectedPersonality = aiPersonalities[Math.floor(Math.random() * aiPersonalities.length)];
                aiStatus.textContent = `AI: 既存人格「${selectedPersonality.username}」（性格: ${selectedPersonality.personalityTrait.substring(0,20)}...）を選択。`;
            }
            
            const avatarColor = Math.floor(Math.random()*127 + 128).toString(16).padStart(2,'0') + Math.floor(Math.random()*127 + 128).toString(16).padStart(2,'0') + Math.floor(Math.random()*127 + 128).toString(16).padStart(2,'0');
            const avatarUrl = `https://placehold.co/40x40/${avatarColor}/FFFFFF?text=${selectedPersonality.avatarSeed}`;

            const allCommentElements = Array.from(commentsList.querySelectorAll('.comment-item, .reply-item'));
            const shouldReply = Math.random() < 0.5 && allCommentElements.length > 0;
            let promptForAIComment;
            let targetParentId = null;
            let basePrompt = selectedPersonality.personalityPrompt; 

            if (shouldReply) { 
                const targetCommentElement = allCommentElements[Math.floor(Math.random() * allCommentElements.length)];
                targetParentId = targetCommentElement.dataset.commentId;
                const targetCommentText = targetCommentElement.querySelector('.comment-text').textContent;
                const targetAuthor = targetCommentElement.querySelector('.font-semibold').textContent;
                aiStatus.textContent = `AI (${selectedPersonality.username}): 「${targetAuthor}」の「${targetCommentText.substring(0,10)}...」に返信準備中...`;

                let replyContext = `\n\n以下のコメントに返信してください:\n`;
                replyContext += `- ${targetAuthor}「${targetCommentText}」\n`;
                
                let currentElement = targetCommentElement;
                for (let i = 0; i < 2; i++) { 
                    const parentWrapper = currentElement.parentElement.closest('.replies-list');
                    if (!parentWrapper) break;
                    const grandParentItem = parentWrapper.parentElement.closest('.comment-item, .reply-item');
                    if (grandParentItem) {
                        const parentText = grandParentItem.querySelector('.comment-text').textContent;
                        const parentAuthor = grandParentItem.querySelector('.font-semibold').textContent;
                        replyContext += `(この返信の文脈となる親コメント: ${parentAuthor}「${parentText}」)\n`;
                        currentElement = grandParentItem;
                    } else {
                        break;
                    }
                }
                promptForAIComment = `${basePrompt}${replyContext}\nあなたの返信内容だけを、あなたのキャラクターとして生成してください。`;
            } else { 
                aiStatus.textContent = `AI (${selectedPersonality.username}): 新しいコメントを準備中...`;
                let newCommentContext = "\n\n最近のコメントや動画内容全体を考慮して、新しいコメントをしてください。\n";
                const recentComments = allCommentElements.slice(0, 3); 
                if (recentComments.length > 0) {
                    newCommentContext += "最近のコメントの例:\n";
                    recentComments.forEach(el => {
                        const text = el.querySelector('.comment-text').textContent;
                        const author = el.querySelector('.font-semibold').textContent;
                        newCommentContext += `- ${author}「${text.substring(0, 40)}...」\n`;
                    });
                } else {
                    newCommentContext += "まだコメントはありません。最初のコメントをどうぞ。\n";
                }
                promptForAIComment = `${basePrompt}${newCommentContext}\nあなたの新しいコメント内容だけを、あなたのキャラクターとして生成してください。`;
            }

            const aiCommentText = await callGeminiAPI(promptForAIComment, apiKey, modelName);

            if (aiCommentText) {
                addCommentToDOM(aiCommentText, selectedPersonality.username, avatarUrl, targetParentId, selectedPersonality);
                if (!targetParentId) { 
                    updateTopLevelCommentCount();
                }
                aiStatus.textContent = `(${selectedPersonality.username}): コメント完了。次回処理待機中...`;
            } else {
                aiStatus.textContent = `(${selectedPersonality.username}): コメント生成失敗。次回処理待機中...`;
            }
        }

        startAiButton.addEventListener('click', async () => {
            if (!apiKeyInput.value) {
                aiStatus.textContent = "APIキーを入力してください。";
                return;
            }
            if (aiIntervalId) return; 
            
            if (firebaseInitialized && !userId && !auth.currentUser) { 
                 aiStatus.textContent = "ユーザー認証待機中...完了後に再試行してください。";
                 try {
                    if (!auth.currentUser) await signInAnonymously(auth);
                 } catch(e) { console.error("Forced anon signin failed", e); }
                 if (!auth.currentUser) return;
            }
            if (firebaseInitialized && userId && aiPersonalities.length === 0) { 
                await loadPersonalities();
            }

            aiStatus.textContent = "AIコメント生成を開始します...";
            aiActionLoop(); 
            aiIntervalId = setInterval(aiActionLoop, 5000); 
            startAiButton.disabled = true;
            stopAiButton.disabled = false;
            apiKeyInput.disabled = true;
            modelNameInput.disabled = true;
        });

        function stopAiCommenting() {
            if (aiIntervalId) {
                clearInterval(aiIntervalId);
                aiIntervalId = null;
                aiStatus.textContent = "AIコメント生成を停止しました。";
                startAiButton.disabled = false;
                stopAiButton.disabled = true;
                apiKeyInput.disabled = false;
                modelNameInput.disabled = false;
            }
        }
        stopAiButton.addEventListener('click', stopAiCommenting);

    </script>
</body>
</html>
